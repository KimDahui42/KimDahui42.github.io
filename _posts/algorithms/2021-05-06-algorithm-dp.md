---
layout: post
title: "DP"
date: 2021-05-06
excerpt: "동아리 발표자료"
tags: [study,algorithms,dp]
category: [Algorithms] 
comments: false
---
# DP
### dp, 동적 계획법이란 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 의미합니다
이는 큰 의미에서 분할 정복과 같은 접근 방식이지만 둘은 문제를 나누는 방식에 차이가 있는데요, dp의 부분 문제는 두 개 이상의 작은 문제를 푸는데 사용될 수 있기 때문에 문제를 여러번 계산하는 대신 한 번만 계산하고, 결과를 dp배열에 저장하고 재활용하여 전체 계산 속도를 향상 시킬 수 있습니다. 이러한 특징을 메모이제이션이라고 칭합니다.
dp는 이 메모이제이션을 통해 부분 문제의 중복계산을 방지할 수 있습니다.
DP는 모든 경로를 확인하기 때문에 그당시의 최선의 해를 구하는 그리디 알고리즘에 비해 시간이 걸릴 수 있다는 단점이 있지만 항상 최적의 해를 구할 수 있습니다.
이러한 특징으로 dp는 경우의 수를 세거나 확률을 계산할 때도 흔히 사용됩니다.
<br>
### dp문제는 식에 따라 시간복잡도가 달라지지만 단순하게 해당 식의 시간을 분석하는 방법은 다음과 같습니다

`(존재하는 부분 문제의 수)X(한 부분 문제를 풀 때 필요한 반복문의 작성횟수)`

이미 계산한 답을 사용하는 것은 상수시간이 사용되기 때문에 전체 수행 시간에 영향을 미치지 않습니다. 
<br>
### dp가 성립하기 위한 조건
* 작은 문제들이 반복된다
* 같은 문제는 구할 때마다 값이 같다

경우의 수를 세는 문제같은 경우에 답이 입력의 크기에 대해 지수적으로 증가할 수 있어 쉽게 오버플로우가 발생할 수 있습니다. 때문에 오버플로우의 대처도 함께 고민하게됩니다.
<br>
### dp는 top-down 방식과 bottom-up 방식으로 구현합니다
#### top-down
dp에 저장된 값이 없다면 재귀로 이전 항의 값을 호출 계산하고 이미 저장된 값이 있다면 저장된 값을 리턴하도록 합니다. 
```
/*예시로 든 코드는 피보나치 수열의 구현으로 피보나치 수열은 모든 항은 바로 앞 두 항의 합인 수열을 의미한다.
코드 작성의 편의상 0번째 항은 0, 첫번째 항은 1을 저장했다.*/

int dp[1000] = { 0, };
dp[0]= 0; dp[1] = 1;
int fibo_recur(int n) {
	if (n < 2)
		return dp[n];
	else if (dp[n] != 0)
		return dp[n];
	return dp[n] = (fibo_recur(n-1) + fibo_recur(n - 2));
}
```
#### bottom-up
큰 문제를 작은 문제로 나누고 작은 문제에서 큰 문제로 답을 구해나가는 방식으로 풀이
```
int dp[1000] = { 0, };
dp[0]= 0; dp[1] = 1;
int fibo_repet(int n) {
	for (int i = 0; i <= n; i++) 
		dp[n] = dp[n - 1] + dp[n - 2];
	return dp[n];
}
```
### <a href="https://www.acmicpc.net/problem/11726">11726번 2xn 타일링</a>
